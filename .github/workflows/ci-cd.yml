name: CI/CD Pipeline with SonarQube

on:
  push:
    branches:
      - main
      - master
      - develop
  pull_request:
    branches:
      - main
      - master

jobs:
  sonarqube-analysis:
    name: SonarQube Analysis
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Shallow clones should be disabled for better analysis
      
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: maven
      
      - name: Cache SonarCloud packages
        uses: actions/cache@v3
        with:
          path: ~/.sonar/cache
          key: ${{ runner.os }}-sonar
          restore-keys: ${{ runner.os }}-sonar
      
      - name: Cache Maven packages
        uses: actions/cache@v3
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2
      
      - name: Build and analyze
        id: sonar-scan
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          set +e
          mvn clean verify sonar:sonar \
            -Dsonar.projectKey=alokpandey_agent_sdlc \
            -Dsonar.organization=${{ secrets.SONAR_ORGANIZATION }} \
            -Dsonar.host.url=https://sonarcloud.io \
            -Dsonar.qualitygate.wait=true
          SONAR_EXIT_CODE=$?
          echo "sonar_exit_code=$SONAR_EXIT_CODE" >> $GITHUB_OUTPUT

          # Extract task ID from Maven output
          TASK_ID=$(grep -oP 'ceTaskId=\K[^,}]+' target/sonar/report-task.txt | head -1)
          echo "task_id=$TASK_ID" >> $GITHUB_OUTPUT

          if [ $SONAR_EXIT_CODE -ne 0 ]; then
            echo "SonarQube quality gate failed with exit code $SONAR_EXIT_CODE"
            exit 1
          fi

      - name: Fetch SonarQube Quality Gate Details
        id: sonar-details
        if: always() && steps.sonar-scan.outputs.sonar_exit_code != '0'
        continue-on-error: true
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          # Fetch quality gate status from SonarCloud API
          RESPONSE=$(curl -s -u "$SONAR_TOKEN:" \
            "https://sonarcloud.io/api/qualitygates/project_status?projectKey=alokpandey_agent_sdlc")

          echo "Quality Gate Response: $RESPONSE"

          # Extract status and conditions
          STATUS=$(echo "$RESPONSE" | jq -r '.projectStatus.status // "UNKNOWN"')
          echo "quality_gate_status=$STATUS" >> $GITHUB_OUTPUT

          # Fetch detailed issues - Bugs
          BUGS_RESPONSE=$(curl -s -u "$SONAR_TOKEN:" \
            "https://sonarcloud.io/api/issues/search?componentKeys=alokpandey_agent_sdlc&resolved=false&types=BUG&ps=50")

          BUGS_COUNT=$(echo "$BUGS_RESPONSE" | jq -r '.total // 0')
          echo "bugs=$BUGS_COUNT" >> $GITHUB_OUTPUT

          # Extract bug details
          echo "$BUGS_RESPONSE" | jq -r '.issues[] | "[\(.severity)] \(.message) - \(.component | split(":") | last) (Line \(.line // "N/A"))"' > /tmp/bugs.txt

          # Fetch detailed issues - Vulnerabilities
          VULNS_RESPONSE=$(curl -s -u "$SONAR_TOKEN:" \
            "https://sonarcloud.io/api/issues/search?componentKeys=alokpandey_agent_sdlc&resolved=false&types=VULNERABILITY&ps=50")

          VULNS_COUNT=$(echo "$VULNS_RESPONSE" | jq -r '.total // 0')
          echo "vulnerabilities=$VULNS_COUNT" >> $GITHUB_OUTPUT

          # Extract vulnerability details
          echo "$VULNS_RESPONSE" | jq -r '.issues[] | "[\(.severity)] \(.message) - \(.component | split(":") | last) (Line \(.line // "N/A"))"' > /tmp/vulnerabilities.txt

          # Fetch detailed issues - Code Smells (limit to top 20)
          CODE_SMELLS_RESPONSE=$(curl -s -u "$SONAR_TOKEN:" \
            "https://sonarcloud.io/api/issues/search?componentKeys=alokpandey_agent_sdlc&resolved=false&types=CODE_SMELL&ps=20")

          CODE_SMELLS_COUNT=$(echo "$CODE_SMELLS_RESPONSE" | jq -r '.total // 0')
          echo "code_smells=$CODE_SMELLS_COUNT" >> $GITHUB_OUTPUT

          # Extract code smell details (top 20)
          echo "$CODE_SMELLS_RESPONSE" | jq -r '.issues[] | "[\(.severity)] \(.message) - \(.component | split(":") | last) (Line \(.line // "N/A"))"' > /tmp/code_smells.txt

          # Fetch Security Hotspots
          HOTSPOTS_RESPONSE=$(curl -s -u "$SONAR_TOKEN:" \
            "https://sonarcloud.io/api/hotspots/search?projectKey=alokpandey_agent_sdlc&ps=50")

          HOTSPOTS_COUNT=$(echo "$HOTSPOTS_RESPONSE" | jq -r '.paging.total // 0')
          echo "security_hotspots=$HOTSPOTS_COUNT" >> $GITHUB_OUTPUT

          # Extract security hotspot details
          echo "$HOTSPOTS_RESPONSE" | jq -r '.hotspots[]? | "[\(.vulnerabilityProbability)] \(.message) - \(.component | split(":") | last) (Line \(.line // "N/A"))"' > /tmp/security_hotspots.txt

      - name: Check Quality Gate
        id: quality-gate
        if: steps.sonar-scan.outputs.sonar_exit_code != '0'
        run: |
          echo "Quality gate failed - creating JIRA ticket"
          exit 1

      - name: Create JIRA ticket on failure
        if: always() && steps.sonar-scan.outputs.sonar_exit_code != '0'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const jiraUrl = process.env.JIRA_URL;
            const jiraEmail = process.env.JIRA_EMAIL;
            const jiraToken = process.env.JIRA_API_TOKEN;
            const projectKey = process.env.JIRA_PROJECT_KEY;

            // Get SonarQube details from previous step
            const qgStatus = process.env.QG_STATUS || 'FAILED';
            const bugs = process.env.BUGS || '0';
            const vulnerabilities = process.env.VULNERABILITIES || '0';
            const codeSmells = process.env.CODE_SMELLS || '0';
            const securityHotspots = process.env.SECURITY_HOTSPOTS || '0';

            // Read detailed issue information from files
            let bugsDetails = [];
            let vulnsDetails = [];
            let codeSmellsDetails = [];
            let hotspotsDetails = [];

            try {
              if (fs.existsSync('/tmp/bugs.txt')) {
                const bugsText = fs.readFileSync('/tmp/bugs.txt', 'utf8').trim();
                if (bugsText) bugsDetails = bugsText.split('\n').filter(line => line.trim());
              }
              if (fs.existsSync('/tmp/vulnerabilities.txt')) {
                const vulnsText = fs.readFileSync('/tmp/vulnerabilities.txt', 'utf8').trim();
                if (vulnsText) vulnsDetails = vulnsText.split('\n').filter(line => line.trim());
              }
              if (fs.existsSync('/tmp/code_smells.txt')) {
                const codeSmellsText = fs.readFileSync('/tmp/code_smells.txt', 'utf8').trim();
                if (codeSmellsText) codeSmellsDetails = codeSmellsText.split('\n').filter(line => line.trim());
              }
              if (fs.existsSync('/tmp/security_hotspots.txt')) {
                const hotspotsText = fs.readFileSync('/tmp/security_hotspots.txt', 'utf8').trim();
                if (hotspotsText) hotspotsDetails = hotspotsText.split('\n').filter(line => line.trim());
              }
            } catch (error) {
              console.log('Error reading issue details:', error.message);
            }

            const auth = Buffer.from(`${jiraEmail}:${jiraToken}`).toString('base64');

            // Helper function to create issue list items
            const createIssueListItems = (issues) => {
              return issues.map(issue => ({
                type: "listItem",
                content: [{
                  type: "paragraph",
                  content: [{ type: "text", text: issue }]
                }]
              }));
            };

            // Build description content
            const descriptionContent = [
              {
                type: "heading",
                attrs: { level: 2 },
                content: [{ type: "text", text: "Quality Gate Failure Summary" }]
              },
              {
                type: "paragraph",
                content: [
                  { type: "text", text: "SonarQube quality gate ", marks: [{ type: "strong" }] },
                  { type: "text", text: qgStatus, marks: [{ type: "strong" }, { type: "textColor", attrs: { color: "#DE350B" } }] },
                  { type: "text", text: ` for commit ${context.sha.substring(0, 7)}` }
                ]
              },
              {
                type: "heading",
                attrs: { level: 3 },
                content: [{ type: "text", text: "Issue Summary" }]
              },
              {
                type: "bulletList",
                content: [
                  {
                    type: "listItem",
                    content: [{
                      type: "paragraph",
                      content: [
                        { type: "text", text: "ðŸ› Bugs: ", marks: [{ type: "strong" }] },
                        { type: "text", text: bugs }
                      ]
                    }]
                  },
                  {
                    type: "listItem",
                    content: [{
                      type: "paragraph",
                      content: [
                        { type: "text", text: "ðŸ”’ Vulnerabilities: ", marks: [{ type: "strong" }] },
                        { type: "text", text: vulnerabilities }
                      ]
                    }]
                  },
                  {
                    type: "listItem",
                    content: [{
                      type: "paragraph",
                      content: [
                        { type: "text", text: "âš ï¸ Security Hotspots: ", marks: [{ type: "strong" }] },
                        { type: "text", text: securityHotspots }
                      ]
                    }]
                  },
                  {
                    type: "listItem",
                    content: [{
                      type: "paragraph",
                      content: [
                        { type: "text", text: "ðŸ’¡ Code Smells: ", marks: [{ type: "strong" }] },
                        { type: "text", text: codeSmells }
                      ]
                    }]
                  }
                ]
              },
            ];

            // Add detailed bugs section if there are bugs
            if (bugsDetails.length > 0) {
              descriptionContent.push({
                type: "heading",
                attrs: { level: 3 },
                content: [{ type: "text", text: `ðŸ› Bugs (${bugs})` }]
              });
              descriptionContent.push({
                type: "bulletList",
                content: createIssueListItems(bugsDetails)
              });
            }

            // Add detailed vulnerabilities section if there are vulnerabilities
            if (vulnsDetails.length > 0) {
              descriptionContent.push({
                type: "heading",
                attrs: { level: 3 },
                content: [{ type: "text", text: `ðŸ”’ Vulnerabilities (${vulnerabilities})` }]
              });
              descriptionContent.push({
                type: "bulletList",
                content: createIssueListItems(vulnsDetails)
              });
            }

            // Add detailed security hotspots section if there are hotspots
            if (hotspotsDetails.length > 0) {
              descriptionContent.push({
                type: "heading",
                attrs: { level: 3 },
                content: [{ type: "text", text: `âš ï¸ Security Hotspots (${securityHotspots})` }]
              });
              descriptionContent.push({
                type: "bulletList",
                content: createIssueListItems(hotspotsDetails)
              });
            }

            // Add detailed code smells section (showing top 20)
            if (codeSmellsDetails.length > 0) {
              const codeSmellsTitle = codeSmells > 20 ? `ðŸ’¡ Code Smells (showing 20 of ${codeSmells})` : `ðŸ’¡ Code Smells (${codeSmells})`;
              descriptionContent.push({
                type: "heading",
                attrs: { level: 3 },
                content: [{ type: "text", text: codeSmellsTitle }]
              });
              descriptionContent.push({
                type: "bulletList",
                content: createIssueListItems(codeSmellsDetails)
              });
            }

            // Add repository details section
            descriptionContent.push(
              {
                type: "heading",
                attrs: { level: 3 },
                content: [{ type: "text", text: "Details" }]
              },
              {
                type: "bulletList",
                content: [
                  {
                    type: "listItem",
                    content: [{
                      type: "paragraph",
                      content: [
                        { type: "text", text: "Repository: ", marks: [{ type: "strong" }] },
                        { type: "text", text: `${context.repo.owner}/${context.repo.repo}` }
                      ]
                    }]
                  },
                  {
                    type: "listItem",
                    content: [{
                      type: "paragraph",
                      content: [
                        { type: "text", text: "Branch: ", marks: [{ type: "strong" }] },
                        { type: "text", text: context.ref.replace('refs/heads/', '') }
                      ]
                    }]
                  },
                  {
                    type: "listItem",
                    content: [{
                      type: "paragraph",
                      content: [
                        { type: "text", text: "Commit: ", marks: [{ type: "strong" }] },
                        { type: "text", text: context.sha }
                      ]
                    }]
                  }
                ]
              },
              {
                type: "heading",
                attrs: { level: 3 },
                content: [{ type: "text", text: "Links" }]
              },
              {
                type: "bulletList",
                content: [
                  {
                    type: "listItem",
                    content: [{
                      type: "paragraph",
                      content: [
                        { type: "text", text: "GitHub Action: ", marks: [{ type: "strong" }] },
                        {
                          type: "text",
                          text: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`,
                          marks: [{
                            type: "link",
                            attrs: { href: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}` }
                          }]
                        }
                      ]
                    }]
                  },
                  {
                    type: "listItem",
                    content: [{
                      type: "paragraph",
                      content: [
                        { type: "text", text: "SonarCloud Dashboard: ", marks: [{ type: "strong" }] },
                        {
                          type: "text",
                          text: "View in SonarCloud",
                          marks: [{
                            type: "link",
                            attrs: { href: `https://sonarcloud.io/dashboard?id=alokpandey_agent_sdlc` }
                          }]
                        }
                      ]
                    }]
                  }
                ]
              }
            ];

            const issueData = {
              fields: {
                project: {
                  key: projectKey
                },
                summary: `SonarQube Quality Gate Failed - ${context.repo.repo} - ${context.sha.substring(0, 7)}`,
                description: {
                  type: "doc",
                  version: 1,
                  content: descriptionContent
                },
                issuetype: {
                  name: "Bug"
                },
                labels: ["sonarqube", "quality-gate-failure", "auto-generated"]
              }
            };

            try {
              const response = await fetch(
                `${jiraUrl}/rest/api/3/issue`,
                {
                  method: 'POST',
                  headers: {
                    'Authorization': `Basic ${auth}`,
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify(issueData)
                }
              );

              if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`HTTP ${response.status}: ${errorText}`);
              }

              const data = await response.json();
              console.log(`JIRA ticket created: ${data.key}`);
              core.setOutput('jira-ticket', data.key);
            } catch (error) {
              console.error('Failed to create JIRA ticket:', error.message);
              throw error;
            }
        env:
          JIRA_URL: ${{ secrets.JIRA_URL }}
          JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
          JIRA_PROJECT_KEY: ${{ secrets.JIRA_PROJECT_KEY }}
          QG_STATUS: ${{ steps.sonar-details.outputs.quality_gate_status }}
          BUGS: ${{ steps.sonar-details.outputs.bugs }}
          VULNERABILITIES: ${{ steps.sonar-details.outputs.vulnerabilities }}
          CODE_SMELLS: ${{ steps.sonar-details.outputs.code_smells }}
          SECURITY_HOTSPOTS: ${{ steps.sonar-details.outputs.security_hotspots }}


name: CI/CD Pipeline with SonarQube

on:
  push:
    branches:
      - main
      - master
      - develop
  pull_request:
    branches:
      - main
      - master

jobs:
  sonarqube-analysis:
    name: SonarQube Analysis
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Shallow clones should be disabled for better analysis
      
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: maven
      
      - name: Cache SonarCloud packages
        uses: actions/cache@v3
        with:
          path: ~/.sonar/cache
          key: ${{ runner.os }}-sonar
          restore-keys: ${{ runner.os }}-sonar
      
      - name: Cache Maven packages
        uses: actions/cache@v3
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2
      
      - name: Build and analyze
        id: sonar-scan
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          set +e
          mvn clean verify sonar:sonar \
            -Dsonar.projectKey=alokpandey_agent_sdlc \
            -Dsonar.organization=${{ secrets.SONAR_ORGANIZATION }} \
            -Dsonar.host.url=https://sonarcloud.io \
            -Dsonar.qualitygate.wait=true
          SONAR_EXIT_CODE=$?
          echo "sonar_exit_code=$SONAR_EXIT_CODE" >> $GITHUB_OUTPUT

          # Extract task ID from Maven output
          TASK_ID=$(grep -oP 'ceTaskId=\K[^,}]+' target/sonar/report-task.txt | head -1)
          echo "task_id=$TASK_ID" >> $GITHUB_OUTPUT

          if [ $SONAR_EXIT_CODE -ne 0 ]; then
            echo "SonarQube quality gate failed with exit code $SONAR_EXIT_CODE"
            exit 1
          fi

      - name: Fetch SonarQube Quality Gate Details
        id: sonar-details
        if: always() && steps.sonar-scan.outputs.sonar_exit_code != '0'
        continue-on-error: true
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          # Fetch quality gate status from SonarCloud API
          RESPONSE=$(curl -s -u "$SONAR_TOKEN:" \
            "https://sonarcloud.io/api/qualitygates/project_status?projectKey=alokpandey_agent_sdlc")

          echo "Quality Gate Response: $RESPONSE"

          # Extract status and conditions
          STATUS=$(echo "$RESPONSE" | jq -r '.projectStatus.status // "UNKNOWN"')
          echo "quality_gate_status=$STATUS" >> $GITHUB_OUTPUT

          # Fetch detailed issues - Bugs
          BUGS_RESPONSE=$(curl -s -u "$SONAR_TOKEN:" \
            "https://sonarcloud.io/api/issues/search?componentKeys=alokpandey_agent_sdlc&resolved=false&types=BUG&ps=50")

          BUGS_COUNT=$(echo "$BUGS_RESPONSE" | jq -r '.total // 0')
          echo "bugs=$BUGS_COUNT" >> $GITHUB_OUTPUT

          # Extract bug details and save to output (base64 encoded to handle special characters)
          BUGS_DETAILS=$(echo "$BUGS_RESPONSE" | jq -r '.issues[] | "[\(.severity)] \(.message) - \(.component | split(":") | last) (Line \(.line // "N/A"))"' | head -50 | base64 -w 0)
          echo "bugs_details=$BUGS_DETAILS" >> $GITHUB_OUTPUT

          # Fetch detailed issues - Vulnerabilities
          VULNS_RESPONSE=$(curl -s -u "$SONAR_TOKEN:" \
            "https://sonarcloud.io/api/issues/search?componentKeys=alokpandey_agent_sdlc&resolved=false&types=VULNERABILITY&ps=50")

          VULNS_COUNT=$(echo "$VULNS_RESPONSE" | jq -r '.total // 0')
          echo "vulnerabilities=$VULNS_COUNT" >> $GITHUB_OUTPUT

          # Extract vulnerability details and save to output (base64 encoded)
          VULNS_DETAILS=$(echo "$VULNS_RESPONSE" | jq -r '.issues[] | "[\(.severity)] \(.message) - \(.component | split(":") | last) (Line \(.line // "N/A"))"' | head -50 | base64 -w 0)
          echo "vulns_details=$VULNS_DETAILS" >> $GITHUB_OUTPUT

          # Fetch detailed issues - Code Smells (limit to top 20)
          CODE_SMELLS_RESPONSE=$(curl -s -u "$SONAR_TOKEN:" \
            "https://sonarcloud.io/api/issues/search?componentKeys=alokpandey_agent_sdlc&resolved=false&types=CODE_SMELL&ps=20")

          CODE_SMELLS_COUNT=$(echo "$CODE_SMELLS_RESPONSE" | jq -r '.total // 0')
          echo "code_smells=$CODE_SMELLS_COUNT" >> $GITHUB_OUTPUT

          # Extract code smell details (top 20) and save to output (base64 encoded)
          CODE_SMELLS_DETAILS=$(echo "$CODE_SMELLS_RESPONSE" | jq -r '.issues[] | "[\(.severity)] \(.message) - \(.component | split(":") | last) (Line \(.line // "N/A"))"' | head -20 | base64 -w 0)
          echo "code_smells_details=$CODE_SMELLS_DETAILS" >> $GITHUB_OUTPUT

          # Fetch Security Hotspots
          HOTSPOTS_RESPONSE=$(curl -s -u "$SONAR_TOKEN:" \
            "https://sonarcloud.io/api/hotspots/search?projectKey=alokpandey_agent_sdlc&ps=50")

          HOTSPOTS_COUNT=$(echo "$HOTSPOTS_RESPONSE" | jq -r '.paging.total // 0')
          echo "security_hotspots=$HOTSPOTS_COUNT" >> $GITHUB_OUTPUT

          # Extract security hotspot details and save to output (base64 encoded)
          HOTSPOTS_DETAILS=$(echo "$HOTSPOTS_RESPONSE" | jq -r '.hotspots[]? | "[\(.vulnerabilityProbability)] \(.message) - \(.component | split(":") | last) (Line \(.line // "N/A"))"' | head -50 | base64 -w 0)
          echo "hotspots_details=$HOTSPOTS_DETAILS" >> $GITHUB_OUTPUT

      - name: Check Quality Gate
        id: quality-gate
        if: steps.sonar-scan.outputs.sonar_exit_code != '0'
        run: |
          echo "Quality gate failed - creating JIRA ticket"
          exit 1

      - name: Create JIRA ticket on failure
        if: always() && steps.sonar-scan.outputs.sonar_exit_code != '0'
        uses: actions/github-script@v7
        with:
          script: |
            const jiraUrl = process.env.JIRA_URL;
            const jiraEmail = process.env.JIRA_EMAIL;
            const jiraToken = process.env.JIRA_API_TOKEN;
            const projectKey = process.env.JIRA_PROJECT_KEY;

            // Get SonarQube details from previous step
            const qgStatus = process.env.QG_STATUS || "FAILED";
            const bugs = process.env.BUGS || "0";
            const vulnerabilities = process.env.VULNERABILITIES || "0";
            const codeSmells = process.env.CODE_SMELLS || "0";
            const securityHotspots = process.env.SECURITY_HOTSPOTS || "0";

            // Get detailed issue information from environment variables (base64 encoded)
            let bugsDetails = [];
            let vulnsDetails = [];
            let codeSmellsDetails = [];
            let hotspotsDetails = [];

            try {
              const bugsDetailsB64 = process.env.BUGS_DETAILS || "";
              const vulnsDetailsB64 = process.env.VULNS_DETAILS || "";
              const codeSmellsDetailsB64 = process.env.CODE_SMELLS_DETAILS || "";
              const hotspotsDetailsB64 = process.env.HOTSPOTS_DETAILS || "";

              console.log("Base64 lengths - Bugs: " + bugsDetailsB64.length + ", Vulns: " + vulnsDetailsB64.length + ", Code Smells: " + codeSmellsDetailsB64.length + ", Hotspots: " + hotspotsDetailsB64.length);

              // Decode base64 and split into lines
              const bugsDetailsText = bugsDetailsB64 ? Buffer.from(bugsDetailsB64, "base64").toString("utf8") : "";
              const vulnsDetailsText = vulnsDetailsB64 ? Buffer.from(vulnsDetailsB64, "base64").toString("utf8") : "";
              const codeSmellsDetailsText = codeSmellsDetailsB64 ? Buffer.from(codeSmellsDetailsB64, "base64").toString("utf8") : "";
              const hotspotsDetailsText = hotspotsDetailsB64 ? Buffer.from(hotspotsDetailsB64, "base64").toString("utf8") : "";

              bugsDetails = bugsDetailsText.trim() ? bugsDetailsText.split("\n").filter(line => line.trim()) : [];
              vulnsDetails = vulnsDetailsText.trim() ? vulnsDetailsText.split("\n").filter(line => line.trim()) : [];
              codeSmellsDetails = codeSmellsDetailsText.trim() ? codeSmellsDetailsText.split("\n").filter(line => line.trim()) : [];
              hotspotsDetails = hotspotsDetailsText.trim() ? hotspotsDetailsText.split("\n").filter(line => line.trim()) : [];

              console.log("Found " + bugsDetails.length + " bugs, " + vulnsDetails.length + " vulnerabilities, " + codeSmellsDetails.length + " code smells, " + hotspotsDetails.length + " security hotspots");
            } catch (error) {
              console.error("Error decoding issue details:", error.message);
              console.error("Stack:", error.stack);
            }

            const auth = Buffer.from(jiraEmail + ":" + jiraToken).toString("base64");

            // Helper function to create issue list items
            const createIssueListItems = (issues) => {
              return issues.map(issue => ({
                type: "listItem",
                content: [{
                  type: "paragraph",
                  content: [{ type: "text", text: issue }]
                }]
              }));
            };

            // Build description content
            const descriptionContent = [
              {
                type: "heading",
                attrs: { level: 2 },
                content: [{ type: "text", text: "Quality Gate Failure Summary" }]
              },
              {
                type: "paragraph",
                content: [
                  { type: "text", text: "SonarQube quality gate ", marks: [{ type: "strong" }] },
                  { type: "text", text: qgStatus, marks: [{ type: "strong" }, { type: "textColor", attrs: { color: "#DE350B" } }] },
                  { type: "text", text: " for commit " + context.sha.substring(0, 7) }
                ]
              },
              {
                type: "heading",
                attrs: { level: 3 },
                content: [{ type: "text", text: "Issue Summary" }]
              },
              {
                type: "bulletList",
                content: [
                  {
                    type: "listItem",
                    content: [{
                      type: "paragraph",
                      content: [
                        { type: "text", text: "ðŸ› Bugs: ", marks: [{ type: "strong" }] },
                        { type: "text", text: bugs }
                      ]
                    }]
                  },
                  {
                    type: "listItem",
                    content: [{
                      type: "paragraph",
                      content: [
                        { type: "text", text: "ðŸ”’ Vulnerabilities: ", marks: [{ type: "strong" }] },
                        { type: "text", text: vulnerabilities }
                      ]
                    }]
                  },
                  {
                    type: "listItem",
                    content: [{
                      type: "paragraph",
                      content: [
                        { type: "text", text: "âš ï¸ Security Hotspots: ", marks: [{ type: "strong" }] },
                        { type: "text", text: securityHotspots }
                      ]
                    }]
                  },
                  {
                    type: "listItem",
                    content: [{
                      type: "paragraph",
                      content: [
                        { type: "text", text: "ðŸ’¡ Code Smells: ", marks: [{ type: "strong" }] },
                        { type: "text", text: codeSmells }
                      ]
                    }]
                  }
                ]
              },
            ];

            // Add detailed bugs section if there are bugs
            if (bugsDetails.length > 0) {
              descriptionContent.push({
                type: "heading",
                attrs: { level: 3 },
                content: [{ type: "text", text: "ðŸ› Bugs (" + bugs + ")" }]
              });
              descriptionContent.push({
                type: "bulletList",
                content: createIssueListItems(bugsDetails)
              });
            }

            // Add detailed vulnerabilities section if there are vulnerabilities
            if (vulnsDetails.length > 0) {
              descriptionContent.push({
                type: "heading",
                attrs: { level: 3 },
                content: [{ type: "text", text: "ðŸ”’ Vulnerabilities (" + vulnerabilities + ")" }]
              });
              descriptionContent.push({
                type: "bulletList",
                content: createIssueListItems(vulnsDetails)
              });
            }

            // Add detailed security hotspots section if there are hotspots
            if (hotspotsDetails.length > 0) {
              descriptionContent.push({
                type: "heading",
                attrs: { level: 3 },
                content: [{ type: "text", text: "âš ï¸ Security Hotspots (" + securityHotspots + ")" }]
              });
              descriptionContent.push({
                type: "bulletList",
                content: createIssueListItems(hotspotsDetails)
              });
            }

            // Add detailed code smells section (showing top 20)
            if (codeSmellsDetails.length > 0) {
              const codeSmellsTitle = codeSmells > 20 ? "ðŸ’¡ Code Smells (showing 20 of " + codeSmells + ")" : "ðŸ’¡ Code Smells (" + codeSmells + ")";
              descriptionContent.push({
                type: "heading",
                attrs: { level: 3 },
                content: [{ type: "text", text: codeSmellsTitle }]
              });
              descriptionContent.push({
                type: "bulletList",
                content: createIssueListItems(codeSmellsDetails)
              });
            }

            // Add repository details section
            descriptionContent.push(
              {
                type: "heading",
                attrs: { level: 3 },
                content: [{ type: "text", text: "Details" }]
              },
              {
                type: "bulletList",
                content: [
                  {
                    type: "listItem",
                    content: [{
                      type: "paragraph",
                      content: [
                        { type: "text", text: "Repository: ", marks: [{ type: "strong" }] },
                        { type: "text", text: context.repo.owner + "/" + context.repo.repo }
                      ]
                    }]
                  },
                  {
                    type: "listItem",
                    content: [{
                      type: "paragraph",
                      content: [
                        { type: "text", text: "Branch: ", marks: [{ type: "strong" }] },
                        { type: "text", text: context.ref.replace("refs/heads/", "") }
                      ]
                    }]
                  },
                  {
                    type: "listItem",
                    content: [{
                      type: "paragraph",
                      content: [
                        { type: "text", text: "Commit: ", marks: [{ type: "strong" }] },
                        { type: "text", text: context.sha }
                      ]
                    }]
                  }
                ]
              },
              {
                type: "heading",
                attrs: { level: 3 },
                content: [{ type: "text", text: "Links" }]
              },
              {
                type: "bulletList",
                content: [
                  {
                    type: "listItem",
                    content: [{
                      type: "paragraph",
                      content: [
                        { type: "text", text: "GitHub Action: ", marks: [{ type: "strong" }] },
                        {
                          type: "text",
                          text: context.serverUrl + "/" + context.repo.owner + "/" + context.repo.repo + "/actions/runs/" + context.runId,
                          marks: [{
                            type: "link",
                            attrs: { href: context.serverUrl + "/" + context.repo.owner + "/" + context.repo.repo + "/actions/runs/" + context.runId }
                          }]
                        }
                      ]
                    }]
                  },
                  {
                    type: "listItem",
                    content: [{
                      type: "paragraph",
                      content: [
                        { type: "text", text: "SonarCloud Dashboard: ", marks: [{ type: "strong" }] },
                        {
                          type: "text",
                          text: "View in SonarCloud",
                          marks: [{
                            type: "link",
                            attrs: { href: "https://sonarcloud.io/dashboard?id=" + context.repo.owner + "_" + context.repo.repo }
                          }]
                        }
                      ]
                    }]
                  }
                ]
              }
            ];

            const issueData = {
              fields: {
                project: {
                  key: projectKey
                },
                summary: "SonarQube Quality Gate Failed - " + context.repo.repo + " - " + context.sha.substring(0, 7),
                description: {
                  type: "doc",
                  version: 1,
                  content: descriptionContent
                },
                issuetype: {
                  name: "Bug"
                },
                labels: ["sonarqube", "quality-gate-failure", "auto-generated"]
              }
            };

            try {
              const response = await fetch(
                jiraUrl + "/rest/api/3/issue",
                {
                  method: "POST",
                  headers: {
                    "Authorization": "Basic " + auth,
                    "Content-Type": "application/json"
                  },
                  body: JSON.stringify(issueData)
                }
              );

              if (!response.ok) {
                const errorText = await response.text();
                throw new Error("HTTP " + response.status + ": " + errorText);
              }

              const data = await response.json();
              console.log("JIRA ticket created: " + data.key);
              core.setOutput("jira-ticket", data.key);
            } catch (error) {
              console.error("Failed to create JIRA ticket:", error.message);
              throw error;
            }
        env:
          JIRA_URL: ${{ secrets.JIRA_URL }}
          JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
          JIRA_PROJECT_KEY: ${{ secrets.JIRA_PROJECT_KEY }}
          QG_STATUS: ${{ steps.sonar-details.outputs.quality_gate_status }}
          BUGS: ${{ steps.sonar-details.outputs.bugs }}
          VULNERABILITIES: ${{ steps.sonar-details.outputs.vulnerabilities }}
          CODE_SMELLS: ${{ steps.sonar-details.outputs.code_smells }}
          SECURITY_HOTSPOTS: ${{ steps.sonar-details.outputs.security_hotspots }}
          BUGS_DETAILS: ${{ steps.sonar-details.outputs.bugs_details }}
          VULNS_DETAILS: ${{ steps.sonar-details.outputs.vulns_details }}
          CODE_SMELLS_DETAILS: ${{ steps.sonar-details.outputs.code_smells_details }}
          HOTSPOTS_DETAILS: ${{ steps.sonar-details.outputs.hotspots_details }}

